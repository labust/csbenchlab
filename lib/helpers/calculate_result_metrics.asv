function metrics = calculate_result_metrics(out)

    ns = fieldnames(out.y);
    metrics = struct;
    for i=1:length(ns)
        y = squeeze(out.y.(ns{i}).Data);
        u = out.u.(ns{i}).Data;
        

        % diffs(i) = sum(abs(y_act - yv))/length(y_act);
        % diffs = max(abs(y_pred - result.hotizon_pred), [], 2);
        % horizon_mse = sum((y_pred - result.hotizon_pred).^2, 2) / length(y_pred);
        
        % ret.result = result;
        % ret.horizon_max_diffs = diffs;
        % ret.horizon_max_avg = sum(diffs) / length(diffs);
        % ret.horizon_mse = horizon_mse;
        % ret.horizon_mse_avg = sum(horizon_mse) / length(horizon_mse);
        
  

        y_ref = out.ref.Data;
       
        if ~isequal(size(y_ref), size(y))
            
            if isequal(size(y_ref), flip(size(y)))
                y = y';
            else
                error(strcat('Cannot calculate metrics. size(y_ref) = ', ...
                    mat2str(size(y_ref))), ...
                    ', size(y) = ', mat2str(size(y)));
            end
        end

        abs_diff = abs(y_ref - y);
    
        ret.mse = sum((y_ref - y).^2) / length(y);
        ret.mae = sum(abs_diff) / length(y);
        ret.power = sum(u.^2) / length(u);

        refs = any(y_ref);
        ref_dims = find(refs);

        ret.qi = dictionary;
        for j=1:length(ref_dims)
            idx = ref_dims(j);


            [is_steps, intervals] = identify_signal_steps(y_ref(:, idx), 5);

            if ~is_steps
                continue
            end
            
            step_metrics = struct;
            for k=1:length(intervals)
                interval = intervals(k, :);
                y_s = y(interval(1):interval(2), idx);
                yref_s = y_ref(interval(1):interval(2), idx);
    
                if max(yref_s, [], "all") > 0
                    step_metrics(k).overshoot = max(max(y_s) - max(yref_s), 0);
                else
                    step_metrics(k).overshoot = max(min(y_s) - min(yref_s), 0);
                end
    
                
                u_s  = u(interval(1):interval(2), :);
                step_metrics(k).overshoot_n = step_metrics(k).overshoot ./ max(abs(yref_s));
                
                abs_diff_s = abs(yref_s - y_s);
                step_metrics(k).mse = sum((yref_s - y_s).^2) / length(y_s);
                step_metrics(k).mae = sum(abs_diff_s) / length(y_s);
                step_metrics(k).power = sum(u_s.^2) / length(u_s);
                
                t_1p_v = 1 - (abs_diff_s <= 0.01 * yref_s);
                t_5p_v = 1 - (abs_diff_s <= 0.05 * yref_s);
                rt_v = abs(y_s) <= 0.63 * abs(yref_s) ;
            
                step_metrics(k).t_1p = sum(t_1p_v) .* out.Ts;
                step_metrics(k).t_5p = sum(t_5p_v) .* out.Ts;
                step_metrics(k).rise_t = sum(rt_v) .* out.Ts;
            end
            a = 5;
            ret.qi(idx) = {step_metrics;
        end
        metrics.(ns{i}) = ret;

    end

end



function [is_steps, intervals] = identify_signal_steps(signal, duration)
    is_steps = 1;
    d = diff(signal);

    f = [1; find(d)];
    intervals = zeros(0, 2);
    for i=2:length(f)
        if (f(i) - f(i-1) < duration)
            is_steps = 0;
            intervals = 0;
            break
        end
        
        if signal(int32((f(i-1) + f(i))/2)) ~= 0
            intervals(end+1, :) = [f(i-1), f(i)];
        end
    end
    
end